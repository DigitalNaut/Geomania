import type { PayloadAction } from "@reduxjs/toolkit";
import { createSelector, createSlice } from "@reduxjs/toolkit";
import { LatLngBounds } from "leaflet";

import { catalogByProperty, pivotTable, shuffleArray } from "src/lib/utils";
import type { ContinentCatalog, CountriesByContinent, CountryCatalog, CountryData } from "src/store/CountryStore/types";
import type { AppThunk, RootState } from "..";

import continentBounds from "src/assets/data/features/continent-bounds-table.json";
import continentData from "src/assets/data/features/continents.json";
import countryData from "src/assets/data/features/countries.json";

export const continentBoundsCatalog = catalogByProperty(
  continentBounds,
  (item) => item.CONTINENT,
  (item) => {
    // The bounds are generated by MapShaper in different order than what Leaflet expects
    // See: https://github.com/mbloch/mapshaper/blob/master/REFERENCE.md#-each
    const [west, south, east, north] = item.BBOX;
    return new LatLngBounds([south ?? 0, west ?? 0], [north ?? 0, east ?? 0]);
  },
);
export const countryCatalog: CountryCatalog = catalogByProperty(countryData, ({ GU_A3 }) => GU_A3);
export const continentCatalog: ContinentCatalog = catalogByProperty(continentData, ({ CONTINENT }) => CONTINENT);
export const countriesByContinent: CountriesByContinent = pivotTable(countryCatalog, "CONTINENT", ({ GU_A3 }) => GU_A3);
export const continents = [...Object.keys(countriesByContinent).sort()] as const;

export type ActivityState = {
  autoRequeue: boolean;
  currentContinent: string | null;
  queue: (string | undefined)[];
  currentCountry: CountryData | null;
  previousCountry: CountryData | null;
  blacklistedCountries: string[] | null;
  visitedCountries: string[];
  shuffle: boolean;
};

type CountryStoreState = {
  quiz: ActivityState;
  review: ActivityState;
};

export type ActivityType = keyof CountryStoreState;

export const initialState: CountryStoreState = {
  quiz: {
    autoRequeue: true,
    currentCountry: null,
    previousCountry: null,
    currentContinent: null,
    queue: [],
    blacklistedCountries: null,
    visitedCountries: [],
    shuffle: true,
  },
  review: {
    autoRequeue: true,
    currentCountry: null,
    previousCountry: null,
    currentContinent: null,
    queue: [],
    blacklistedCountries: null,
    visitedCountries: [],
    shuffle: true,
  },
};

type NewQueuePayload = {
  activityType: keyof CountryStoreState;
};

const countryStoreSlice = createSlice({
  name: "countryStore",
  initialState,
  reducers: {
    newQueue(
      state,
      {
        payload: { activityType, continent, shuffle, blacklistedCountries = [] },
      }: PayloadAction<
        NewQueuePayload & {
          continent: string;
          blacklistedCountries: string[];
          shuffle: boolean;
        }
      >,
    ) {
      const activity = state[activityType];
      let newQueue = countriesByContinent[continent].slice();

      if (blacklistedCountries.length > 0) {
        newQueue = newQueue.filter((a3) => !blacklistedCountries.includes(a3));
        activity.blacklistedCountries = blacklistedCountries;
      }

      if (shuffle) {
        newQueue = shuffleArray(newQueue);
      } else {
        newQueue.sort();
      }

      activity.currentContinent = continent;
      activity.shuffle = shuffle;

      const nextCountry = newQueue.pop();
      activity.previousCountry = null;
      activity.currentCountry = nextCountry ? countryCatalog[nextCountry] : null;
      activity.queue = newQueue;
    },

    nextCountryInQueue(state, { payload: activityType }: PayloadAction<ActivityType>) {
      const activity = state[activityType];

      if (!activity.currentContinent) return;

      // If the queue is empty, and we're not auto requeueing, then we're done
      if (activity.queue.length === 0) {
        if (!activity.autoRequeue) return;

        // Auto requeue
        activity.queue = countriesByContinent[activity.currentContinent].slice();
        activity.visitedCountries = [];
      }

      const nextCountryA3 = activity.queue[0];

      if (nextCountryA3) {
        const country = countryCatalog[nextCountryA3];
        activity.previousCountry = activity.currentCountry;
        activity.currentCountry = countryCatalog[country.GU_A3];
      }

      activity.queue = activity.queue.slice(1);
    },

    resetQueue(state, { payload: activityType }: PayloadAction<ActivityType>) {
      const activityState = state[activityType];

      if (!activityState.currentContinent) return;

      let newQueue = countriesByContinent[activityState.currentContinent].slice();

      if (activityState.blacklistedCountries !== null && activityState.blacklistedCountries.length) {
        newQueue = newQueue.filter((a3) => !activityState.blacklistedCountries?.includes(a3));
      }

      if (activityState.shuffle) {
        newQueue = shuffleArray(newQueue);
      } else {
        newQueue.sort();
      }

      const nextCountry = newQueue[0];
      activityState.previousCountry = null;
      activityState.currentCountry = countryCatalog[nextCountry];
      activityState.queue = newQueue.slice(1);
    },

    clearQueue(state, { payload: activityType }: PayloadAction<ActivityType>) {
      const activity = state[activityType];
      activity.queue = [];
    },

    blacklistCountry(
      state,
      { payload: { countryA3, type } }: PayloadAction<{ countryA3: string; type: keyof CountryStoreState }>,
    ) {
      const activity = state[type];

      if (activity.blacklistedCountries) {
        activity.blacklistedCountries.push(countryA3);
      } else {
        activity.blacklistedCountries = [countryA3];
      }

      if (activity.queue.length > 0) {
        activity.queue = activity.queue.filter((a3) => a3 !== countryA3) || null;
      }

      return state;
    },

    removeFromQueue(
      state,
      { payload: { countryA3, type } }: PayloadAction<{ countryA3: string; type: keyof CountryStoreState }>,
    ) {
      const activity = state[type];
      activity.queue = activity.queue.filter((a3) => a3 !== countryA3) || null;
    },

    setCurrentCountryByCode(
      state,
      { payload: { countryA3, activityType } }: PayloadAction<{ countryA3: string | null; activityType: ActivityType }>,
    ) {
      const activityState = state[activityType];

      if (activityState.currentCountry?.GU_A3 === countryA3) return;

      activityState.previousCountry = activityState.currentCountry;
      activityState.currentCountry = countryA3 ? countryCatalog[countryA3] : null;
    },

    clearVisitedCountries(state, { payload: activityType }: PayloadAction<ActivityType>) {
      const activity = state[activityType];
      activity.visitedCountries = [];
    },

    addVisitedCountry(
      state,
      {
        payload: { countryA3: country, activityType },
      }: PayloadAction<{ countryA3: string; activityType: ActivityType }>,
    ) {
      const activity = state[activityType];

      if (activity.visitedCountries.includes(country)) return;

      if (activity.visitedCountries) {
        activity.visitedCountries = [...activity.visitedCountries, country];
      } else {
        activity.visitedCountries = [country];
      }
    },
  },
});

export const {
  newQueue,
  clearQueue,
  removeFromQueue,
  setCurrentCountryByCode,
  clearVisitedCountries,
  blacklistCountry,
  addVisitedCountry,
} = countryStoreSlice.actions;
export default countryStoreSlice.reducer;

export function getNextCountry(activityType: keyof CountryStoreState): AppThunk<CountryData | null> {
  return function (dispatch, getState) {
    dispatch(countryStoreSlice.actions.nextCountryInQueue(activityType));
    return getState().countryStore[activityType].currentCountry;
  };
}

/**
 * It'll:
 * - Override the current country
 * - Remove the country from the queue
 * - Add the country to the visited countries
 * @param activity
 * @returns
 */
export function changeCurrentCountry(activity: {
  activityType: keyof CountryStoreState;
  countryA3: string;
}): AppThunk<CountryData | null> {
  return function (dispatch) {
    dispatch(setCurrentCountryByCode(activity));
    dispatch(removeFromQueue({ type: activity.activityType, countryA3: activity.countryA3 }));
    dispatch(addVisitedCountry(activity));

    return countryCatalog[activity.countryA3];
  };
}

export function resetActivity(activityType: ActivityType): AppThunk {
  return function (dispatch) {
    dispatch(setCurrentCountryByCode({ countryA3: "", activityType }));
    dispatch(clearVisitedCountries(activityType));
    dispatch(clearQueue(activityType));
  };
}

export function selectCurrentCountryA3(activity?: ActivityType | null) {
  return createSelector(
    (state: RootState) => {
      if (!activity) return null;
      return state.countryStore[activity].currentCountry;
    },
    (country) => country?.GU_A3 || null,
  );
}

export function selectPreviousCountryA3(activityType?: ActivityType | null) {
  return createSelector(
    (state: RootState) => {
      if (!activityType) return null;
      return state.countryStore[activityType].previousCountry;
    },
    (country) => country?.GU_A3 || null,
  );
}

export function selectCurrentCountryData(activityType?: ActivityType | null) {
  return createSelector(
    (state: RootState) => {
      if (!activityType) return null;
      return state.countryStore[activityType];
    },
    (activityState) => activityState?.currentCountry || null,
  );
}

export function selectCurrentContinent(activityType?: ActivityType | null) {
  return createSelector(
    (state: RootState) => {
      if (!activityType) return null;
      return state.countryStore[activityType];
    },
    (activityState) => activityState?.currentContinent || null,
  );
}

export function selectActivityState(activityType: ActivityType) {
  return createSelector(
    (state: RootState) => state.countryStore[activityType],
    (activityState) => ({ ...activityState }),
  );
}
